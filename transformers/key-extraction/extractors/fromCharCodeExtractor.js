import * as t from '@babel/types';
import { getStringFromLiteral } from '../utils/extractionUtils.js';
import * as babel from '@babel/core';

/**
 * Extractor for keys constructed using `String.fromCharCode()`.
 *
 * This extractor is designed to handle patterns where a key is generated by
 * calling `String.fromCharCode()` with an array of character codes. It can
 * handle several variations of this pattern:
 *
 * 1.  **Direct Spread of an Array**:
 *     -   `String.fromCharCode(...[107, 101, 121])`
 *     -   Here, the array `[107, 101, 121]` is directly spread into `fromCharCode`.
 *
 * 2.  **Spread of a Mapped Array**:
 *     -   `String.fromCharCode(...[208, 204, 220].map(c => c - 101))`
 *     -   In this case, an array is first transformed using `.map()`, and the
 *         resulting array is then spread into `fromCharCode`. The extractor
 *         will evaluate the map function to resolve the final character codes.
 *
 * 3.  **Spread of an Array Identifier**:
 *     -   `const codes = [107, 101, 121];`
 *     -   `String.fromCharCode(...codes)`
 *     -   The extractor can resolve the array identifier `codes` to its
 *         statically defined value and then extract the key.
 *
 * The extractor works by identifying `CallExpression` nodes where the callee is
 * `String.fromCharCode`. It then analyzes the arguments to handle the different
 * patterns described above.
 *
 * @param {object} state - The state object for the extractor.
 * @param {Array<object>} state.keys - The array to which extracted keys will be added.
 */

// Helper to analyze the callback function of an Array.prototype.map() call
const analyzeMapCallback = (funcPath, t) => {
  if (!funcPath.isFunction()) {
    // Not a function, can't analyze
    return { usesParameter: true };
  }

  const param = funcPath.node.params[0];
  // If there's no parameter, it's definitely not using it.
  if (!param) {
    return { usesParameter: false };
  }

  // Check if the parameter is referenced in the function body.
  const binding = funcPath.scope.getBinding(param.name);
  return { usesParameter: binding.referenced };
};

const createFromCharCodeExtractor = (foundKeys, nonHexCandidates, wrongLengthCandidates, aliasMap = {}) => {
  const resolveAlias = name => {
    let currentName = name;
    const seen = new Set();
    while (aliasMap[currentName]) {
      if (seen.has(currentName)) break; // circular
      seen.add(currentName);
      currentName = aliasMap[currentName];
    }
    return currentName;
  };

  return {
    CallExpression(path) {
      const { callee, arguments: args } = path.node;

      // Check if the callee ends with .fromCharCode, or is a direct alias
      const isFromCharCode =
        (t.isMemberExpression(callee) && getStringFromLiteral(callee.property) === 'fromCharCode') ||
        (t.isIdentifier(callee) && resolveAlias(callee.name) === 'fromCharCode');

      if (!isFromCharCode || args.length !== 1 || !t.isSpreadElement(args[0])) {
        return;
      }

      const spreadArgument = args[0].argument;

      let charCodes;

      // Case 1: String.fromCharCode(...[1, 2, 3])
      if (t.isArrayExpression(spreadArgument)) {
        charCodes = spreadArgument.elements
          .map(element => {
            if (t.isNumericLiteral(element)) {
              return element.value;
            }
            // Handle other literal types if necessary
            return null;
          })
          .filter(code => code !== null);
      }
      // Case 2: String.fromCharCode(...someArray.map(fn))
      else if (
        t.isCallExpression(spreadArgument) &&
        t.isMemberExpression(spreadArgument.callee) &&
        getStringFromLiteral(spreadArgument.callee.property) === 'map'
      ) {
        const arraySource = spreadArgument.callee.object;
        const mapFunction = spreadArgument.arguments[0];

        let arrayValues;
        if (t.isArrayExpression(arraySource)) {
          arrayValues = arraySource.elements.map(e => e.value);
        } else if (t.isIdentifier(arraySource)) {
          const binding = path.scope.getBinding(arraySource.name);
          if (binding && binding.path.isVariableDeclarator() && t.isArrayExpression(binding.path.node.init)) {
            arrayValues = binding.path.node.init.elements.map(e => e.value);
          }
        }

        if (arrayValues && (t.isArrowFunctionExpression(mapFunction) || t.isFunctionExpression(mapFunction))) {
          // Evaluate the map function using AST analysis instead of `new Function`
          const mapParam = mapFunction.params[0];
          const body = mapFunction.body;
          let returnExpr;

          if (t.isBinaryExpression(body)) {
            returnExpr = body;
          } else if (t.isBlockStatement(body)) {
            // Heuristic: find the first return statement in the function body.
            // This is safer than execution but may not be correct for complex control flow.
            let foundReturn;
            babel.traverse(
              mapFunction,
              {
                ReturnStatement(p) {
                  foundReturn = p.node;
                  p.stop();
                }
              },
              path.scope,
              path
            );
            if (foundReturn) {
              returnExpr = foundReturn.argument;
            }
          }

          if (returnExpr) {
            if (t.isBinaryExpression(returnExpr) && mapParam && t.isIdentifier(mapParam)) {
              const paramName = mapParam.name;
              const { left, operator, right } = returnExpr;
              if (t.isIdentifier(left) && left.name === paramName && t.isNumericLiteral(right)) {
                const opFunc = {
                  '+': (a, b) => a + b,
                  '-': (a, b) => a - b,
                  '*': (a, b) => a * b,
                  '/': (a, b) => a / b
                }[operator];
                if (opFunc) {
                  charCodes = arrayValues.map(val => opFunc(val, right.value));
                }
              }
            } else if (t.isNumericLiteral(returnExpr)) {
              charCodes = arrayValues.map(() => returnExpr.value);
            }
          } else {
            // Fallback for complex map functions that can't be statically analyzed.
            // Assume it's an identity function as a last resort.
            charCodes = arrayValues;
          }
        }
      }
      // Case 3: const codes = [1,2,3]; String.fromCharCode(...codes)
      else if (t.isIdentifier(spreadArgument)) {
        const binding = path.scope.getBinding(spreadArgument.name);
        if (binding && t.isVariableDeclarator(binding.path.node) && t.isArrayExpression(binding.path.node.init)) {
          charCodes = binding.path.node.init.elements
            .map(element => {
              if (t.isNumericLiteral(element)) {
                return element.value;
              }
              return null;
            })
            .filter(code => code !== null);
        }
      }

      if (charCodes) {
        const key = String.fromCharCode(...charCodes);
        if (/^[0-9a-f]+$/i.test(key)) {
          if (key.length === 32 || key.length === 64) {
            foundKeys.push({ key: key, type: 'String.fromCharCode' });
          } else {
            wrongLengthCandidates.push(key);
          }
        } else {
          nonHexCandidates.push(key);
        }
      }
    }
  };
};

export default createFromCharCodeExtractor;
